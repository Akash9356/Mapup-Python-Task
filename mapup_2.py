# -*- coding: utf-8 -*-
"""Mapup-2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1v2Nmpfdo892HdKSQE2AD8vWcWOaXWkZq

# **Python Task - 2**
"""

pip install networkx

import pandas as pd
import networkx as nx

def calculate_distance_matrix(csv_file_path):
    # Load the CSV dataset into a pandas DataFrame
    df = pd.read_csv(csv_file_path)

    # Create an undirected graph using NetworkX
    G = nx.Graph()

    # Add edges with distances to the graph
    for _, row in df.iterrows():
        G.add_edge(row['id_start'], row['id_end'], distance=row['distance'])
        G.add_edge(row['id_end'], row['id_start'], distance=row['distance'])

    # Calculate the shortest paths between toll booths
    all_tolls = pd.concat([df['id_start'], df['id_end']]).unique()
    distance_matrix = pd.DataFrame(index=all_tolls, columns=all_tolls)

    for toll_A in all_tolls:
        for toll_B in all_tolls:
            if toll_A == toll_B:
                distance_matrix.at[toll_A, toll_B] = 0
            else:
                try:
                    # Use undirected graph to find shortest paths
                    distance_matrix.at[toll_A, toll_B] = nx.shortest_path_length(G, toll_A, toll_B, weight='distance')
                except nx.NetworkXNoPath:
                    distance_matrix.at[toll_A, toll_B] = float('inf')

    return distance_matrix

# Example usage:
csv_file_path = '/content/dataset-3.csv'
result_distance_matrix = calculate_distance_matrix(csv_file_path)

# Display the resulting distance matrix
print("Distance Matrix:")
print(result_distance_matrix)

"""# **Question 2: Unroll Distance Matrix**"""

import numpy as np

def make_matrix_symmetric(matrix):
    """
    Make a matrix symmetric by copying the upper triangular part to the lower triangular part.

    Parameters:
    - matrix: The input matrix (NumPy array).

    Returns:
    - symmetric_matrix: The symmetric matrix (NumPy array).
    """
    # Extract the upper triangular part and mirror it to make the matrix symmetric
    symmetric_matrix = np.triu(matrix) + np.triu(matrix, 1).T

    return symmetric_matrix

# Example usage:
# Assuming you have a 43x43 matrix
input_matrix = result_distance_matrix

symmetric_matrix = make_matrix_symmetric(input_matrix)

print("Original Matrix:")
#print(input_matrix)
print("\nSymmetric Matrix:")
print(symmetric_matrix)

import pandas as pd
import numpy as np

def unroll_distance_matrix(symmetric_matrix):
    """
    Unroll a symmetric matrix into a DataFrame with columns id_start, id_end, and distance.

    Parameters:
    - symmetric_matrix: The symmetric matrix as a NumPy array.

    Returns:
    - unrolled_df: The resulting DataFrame with columns id_start, id_end, and distance.
    """
    # Get the size of the symmetric matrix
    matrix_size = symmetric_matrix.shape[0]

    # Create a list to store rows of the unrolled DataFrame
    unrolled_rows = []

    # Iterate through unique pairs of id_start and id_end
    for start_id in range(matrix_size):
        for end_id in range(start_id + 1, matrix_size):  # Avoid duplicates and the diagonal
            # Get the distance value for the pair (start_id, end_id)
            distance_value = symmetric_matrix[start_id, end_id]

            # Append the row to the unrolled_rows list
            unrolled_rows.append({'id_start': start_id, 'id_end': end_id, 'distance': distance_value})

    # Create the resulting DataFrame from the unrolled_rows list
    unrolled_df = pd.DataFrame(unrolled_rows)

    return unrolled_df

# Example usage:
# Assuming symmetric_matrix is your symmetric matrix

result_df = unroll_distance_matrix(symmetric_matrix)
print(result_df)

"""# Question 3: Finding IDs within Percentage **Threshold**"""

import pandas as pd

def find_ids_within_ten_percentage_threshold(df, reference_value):
    """
    Find IDs within a 10% threshold of the average distance for a reference value.

    Parameters:
    - df: The input DataFrame with columns id_start, id_end, and distance.
    - reference_value: The reference value (integer) from the id_start column.

    Returns:
    - sorted_ids: A sorted list of values from the id_start column within the threshold.
    """
    # Filter the DataFrame for rows with the specified reference value
    reference_rows = df[df['id_start'] == reference_value]

    # Calculate the average distance for the reference value
    average_distance = reference_rows['distance'].mean()

    # Calculate the threshold range (10% of the average distance)
    threshold = 0.1 * average_distance

    # Filter the DataFrame for rows within the 10% threshold
    within_threshold_rows = df[
        (df['id_start'] != reference_value) &  # Exclude the reference value itself
        (df['distance'] >= average_distance - threshold) &
        (df['distance'] <= average_distance + threshold)
    ]

    # Get unique values from the 'id_start' column and sort them
    sorted_ids = sorted(within_threshold_rows['id_start'].unique())

    return sorted_ids

# Example usage:
# Assuming df is your DataFrame from Question 2
df = result_df

reference_value = 1

result = find_ids_within_ten_percentage_threshold(df, reference_value)
print(result)

"""# **Question 4: Calculate Toll Rate**"""

import pandas as pd

def calculate_toll_rate(df):
    """
    Calculate toll rates based on vehicle types and add columns to the input DataFrame.

    Parameters:
    - df: The input DataFrame with columns id_start, id_end, distance.

    Returns:
    - df_with_toll_rates: The DataFrame with added columns for moto, car, rv, bus, and truck toll rates.
    """
    # Create a copy of the input DataFrame to avoid modifying the original
    df_with_toll_rates = df.copy()

    # Define rate coefficients for each vehicle type
    rate_coefficients = {
        'moto': 0.8,
        'car': 1.2,
        'rv': 1.5,
        'bus': 2.2,
        'truck': 3.6
    }

    # Calculate toll rates for each vehicle type and add columns to the DataFrame
    for vehicle_type, rate_coefficient in rate_coefficients.items():
        column_name = f'{vehicle_type}_toll'
        df_with_toll_rates[column_name] = df['distance'] * rate_coefficient

    return df_with_toll_rates

# Example usage:
# Assuming df is your DataFrame from Question 2
df = result_df

result_df_1 = calculate_toll_rate(df)
print(result_df_1)

"""# Question 5: Calculate Time-Based Toll **Rates**"""

import pandas as pd
from datetime import time

def calculate_time_based_toll_rates(df):
    # Create a copy of the input DataFrame to avoid modifying the original
    df_with_time_based_toll = df.copy()

    # Define time ranges and discount factors for weekdays and weekends
    weekday_time_ranges = [
        (time(0, 0, 0), time(10, 0, 0)),
        (time(10, 0, 0), time(18, 0, 0)),
        (time(18, 0, 0), time(23, 59, 59))
    ]

    weekend_time_range = (time(0, 0, 0), time(23, 59, 59))

    weekday_discount_factors = [0.8, 1.2, 0.8]
    weekend_discount_factor = 0.7

    # Create empty lists to store the new columns
    start_day_list = []
    start_time_list = []
    end_day_list = []
    end_time_list = []

    # Iterate through each unique (id_start, id_end) pair
    for _, group_df in df_with_time_based_toll.groupby(['id_start', 'id_end']):
        # Create rows for each time range and day
        for day in range(7):  # 0 represents Monday, 1 represents Tuesday, and so on
            for start_time, end_time in (weekday_time_ranges if day < 5 else [weekend_time_range]):
                # Append values to the lists for each row
                start_day_list.append(day)
                start_time_list.append(start_time)
                end_day_list.append(day)
                end_time_list.append(end_time)

    # Add the new columns to the DataFrame
    df_with_time_based_toll['start_day'] = start_day_list
    df_with_time_based_toll['start_time'] = start_time_list
    df_with_time_based_toll['end_day'] = end_day_list
    df_with_time_based_toll['end_time'] = end_time_list

    # Iterate through each vehicle column and apply the discount factor based on the time range
    for vehicle_column in ['moto', 'car', 'rv', 'bus', 'truck']:
        toll_column = f'{vehicle_column}_toll'

        # Apply the discount factor based on the time range
        df_with_time_based_toll[toll_column] *= df_with_time_based_toll.apply(
            lambda row: (
                weekday_discount_factors[weekday_time_ranges.index((row['start_time'], row['end_time']))]
                if row['start_day'] < 5
                else weekend_discount_factor
            ),
            axis=1
        )

    return df_with_time_based_toll

# Example usage:
# Assuming df is your DataFrame from Question 3
df = pd.DataFrame({
    'id_start': [1, 1, 2, 2, 3, 3],
    'id_end': [2, 3, 1, 3, 1, 2],
    'distance': [10, 20, 30, 40, 50, 60]
})

result_df = calculate_time_based_toll_rates(df)
print(result_df)